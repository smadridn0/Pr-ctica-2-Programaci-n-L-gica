ruta(medellin,bogota, avion, 8, 11, 100, si).
ruta(medellin,bogota, avion, 3, 5, 200, si).
ruta(bogota,cartagena, avion, 2, 3, 23, si).
ruta(bogota,cartagena, avion, 5, 7, 56, si).
ruta(cartagena,pasto, avion, 3, 4, 9, si).
ruta(bogota,pasto, avion, 2, 3, 90, si).


mayor_o_igual(X, Y) :-X >= Y.                                                                                                                                                                                                                                                                                                                                                                                                                                 %Por que el >= no funciona para variables
camino(Origen, Destino, Camino, Preciofinal, Hfinal) :- camino_acum(Origen, Destino, [Origen], Camino, Preciofinal, 0, Hfinal,0,0).                                                                                                                                                                                                                                                                                                                           % crea la funcion auxiliar para poder hacer acumuladores que guarden las ciudades visitadas, y el precio y tiempo total.
camino_acum(Origen, Origen, Visitados, Camino, Preciofin, Preciofin,Hfinal,Hfinal,Posi) :- reverse(Visitados, Camino).                                                                                                                                                                                                                                                                                                                                        %En el caso base, iguala el valor del precio y tiempo acumulado con el final, e invierte la lista de visitados para que aparesca en orden. Ocurre cuando el origen y destino son iguales.
camino_acum(Origen, Destino, Visitados, Camino,Preciofin, Precioaccum,Hfinal, Haccum, Posi):-ruta(Origen, Intermedio,_,Hsal,Hlleg,Precioruta,si),mayor_o_igual(Hsal, Posi),H is Haccum + Hlleg-Hsal ,Precio is Precioaccum+Precioruta, \+ member(Intermedio, Visitados), camino_acum(Intermedio, Destino, [Intermedio | Visitados], Camino, Preciofin, Precio, Hfinal, H,Hlleg).                                                                              %busca una ruta disponible (ultimo argumento "si"), que parta de el origen a un punto intermedio, que no se halla visitado antes, que sea temporalmente posible(que no salga antes que la llegada del destino anterior) y que acumule las horas de viaje y el precio. Despues se llama a si mismo recursivamente desde el punto intermedio.
cheapest(Origen, Destino, Camino, Preciofinal,Hfinal):-findall((Preciofinal, Camino), camino(Origen, Destino, Camino, Preciofinal,Hfinal), Values), min_member((Preciofinal, Camino),Values).                                                                                                                                                                                                                                                                 %toma todos los caminos posibles entre los dos puntos dados con findall y escoge el que tenga el menor precio final.
fastest(Origen, Destino, Camino, Preciofinal,Hfinal):-findall((Hfinal, Camino), camino(Origen, Destino, Camino, Preciofinal,Hfinal), Values), min_member((Hfinal, Camino),Values).                                                                                                                                                                                                                                                                            %similar a cheapest, toma todos los caminos y escoge el que tenga el menor tiempo final
caminoentre(Origen, Destino, Camino, Preciofinal, Hfinal,Hde,Harr) :- caminoe_acum(Origen, Destino, [Origen], Camino, Preciofinal, 0, Hfinal,0,0,Hde,Harr).                                                                                                                                                                                                                                                                                                   %Es casi igual a la función camino, solo que añade un valor de hora maxima y minima para filtrar el tiempo posible.
caminoe_acum(Origen, Origen, Visitados, Camino, Preciofin, Preciofin,Hfinal,Hfinal,Posi, Hde,Harr) :- reverse(Visitados, Camino).                                                                                                                                                                                                                                                                                                                             %mismo caso base que en camino normal
caminoe_acum(Origen, Destino, Visitados, Camino,Preciofin, Precioaccum,Hfinal, Haccum, Posi,Hde,Harr):-ruta(Origen, Intermedio,_,Hsal,Hlleg,Precioruta,si),mayor_o_igual(Harr, Hlleg),mayor_o_igual(Hsal, Hde),mayor_o_igual(Hsal, Posi),H is Haccum + Hlleg-Hsal ,Precio is Precioaccum+Precioruta, \+ member(Intermedio, Visitados), caminoe_acum(Intermedio, Destino, [Intermedio | Visitados], Camino, Preciofin, Precio, Hfinal, H,Hlleg,Hde,Harr).      %casi igual al camino normal, pero revisa que no se tomen rutas que partan o lleguen por fuera del margen establecido
cheapestentre(Origen, Destino, Camino, Preciofinal,Hfinal,Min,Max):-findall((Preciofinal, Camino), caminoentre(Origen, Destino, Camino, Preciofinal,Hfinal,Min,Max), Values), min_member((Preciofinal, Camino),Values).                                                                                                                                                                                                                                       %igual al cheapest normal, pero usando el caminoentre para filtrar el tiempo
fastestentre(Origen, Destino, Camino, Preciofinal,Hfinal,Min,Max):-findall((Hfinal, Camino), caminoentre(Origen, Destino, Camino, Preciofinal,Hfinal,Min,Max), Values), min_member((Hfinal, Camino),Values).                                                                                                                                                                                                                                                  %igual al fastest normal, pero usando el caminoentre para filtrar el tiempo






